#!/usr/bin/env tsx

class SystematicBranchIntegration {
  private token: string;
  private owner: string = 'stagesen';
  private repo: string = 'stage-senior-platform';
  private baseURL: string = 'https://api.github.com';

  constructor() {
    this.token = process.env.GITHUB_TOKEN || '';
    if (!this.token) {
      throw new Error('GITHUB_TOKEN environment variable is required');
    }
  }

  private async makeRequest(endpoint: string, options: any = {}): Promise<any> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Stage-Senior-Integration-Tool',
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`GitHub API request failed: ${response.status} ${response.statusText}\n${errorText}`);
    }

    return response.json();
  }

  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async testApplicationHealth(): Promise<boolean> {
    console.log('üîç Testing application health...');
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('http://localhost:5000/api/communities', {
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        console.log('‚úÖ Application is healthy and responding');
        return true;
      } else {
        console.log(`‚ùå Application responded with status: ${response.status}`);
        return false;
      }
    } catch (error) {
      console.log(`‚ùå Application health check failed: ${error}`);
      return false;
    }
  }

  async createPullRequest(headBranch: string, baseBranch: string = 'codex', title?: string): Promise<number | null> {
    const prTitle = title || `Integration: Merge ${headBranch} into ${baseBranch}`;
    console.log(`üìù Creating pull request: ${headBranch} ‚Üí ${baseBranch}`);
    
    try {
      const pr = await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls`, {
        method: 'POST',
        body: JSON.stringify({
          title: prTitle,
          head: headBranch,
          base: baseBranch,
          body: `Automatically created pull request for systematic branch integration.\n\n**Branch:** ${headBranch}\n**Target:** ${baseBranch}\n\n**Generated by systematic integration tool**`
        })
      });

      console.log(`‚úÖ Created PR #${pr.number}: ${prTitle}`);
      return pr.number;
    } catch (error) {
      console.error(`‚ùå Failed to create pull request for ${headBranch}:`, error);
      return null;
    }
  }

  async mergePullRequest(prNumber: number, mergeMethod: 'merge' | 'squash' | 'rebase' = 'squash'): Promise<boolean> {
    console.log(`üîÑ Merging PR #${prNumber} using ${mergeMethod} method...`);
    
    try {
      const mergeResult = await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls/${prNumber}/merge`, {
        method: 'PUT',
        body: JSON.stringify({
          commit_title: `Merge PR #${prNumber}`,
          commit_message: `Merged via systematic integration`,
          merge_method: mergeMethod
        })
      });

      console.log(`‚úÖ Successfully merged PR #${prNumber}`);
      console.log(`   SHA: ${mergeResult.sha}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to merge PR #${prNumber}:`, error);
      return false;
    }
  }

  async deleteBranch(branchName: string): Promise<boolean> {
    console.log(`üóëÔ∏è Deleting branch: ${branchName}`);
    
    try {
      await this.makeRequest(`/repos/${this.owner}/${this.repo}/git/refs/heads/${branchName}`, {
        method: 'DELETE'
      });

      console.log(`‚úÖ Successfully deleted branch: ${branchName}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to delete branch ${branchName}:`, error);
      return false;
    }
  }

  async executeSystematicIntegration(): Promise<void> {
    console.log('üöÄ Starting Systematic Branch Integration');
    console.log('=' .repeat(80));

    // Feature branches to integrate (excluding the conflicted one)
    const featureBranches = [
      'feature/fix-blog-page-filtering-functionality',
      'feature/fix-map-feature-in-community-detail-page',
      'feature/fix-map-scrolling-behavior-on-communities-page',
      'feature/remove-text-and-button-from-footer',
      'feature/update-testimonial-section-design',
      'kf9v10-codex/standardize-booking-flow-for-tour-requests'
    ];

    let successCount = 0;
    let failureCount = 0;
    const mergedBranches: string[] = [];
    const failedBranches: string[] = [];

    console.log(`\nüìã Processing ${featureBranches.length} feature branches...`);

    // Step 1: Create PRs and merge feature branches into codex
    for (const branch of featureBranches) {
      console.log(`\nüîÑ Processing branch: ${branch}`);
      
      try {
        // Create PR
        const prNumber = await this.createPullRequest(branch, 'codex');
        
        if (prNumber) {
          // Wait a moment for PR to be ready
          await this.delay(2000);
          
          // Attempt to merge
          const mergeSuccess = await this.mergePullRequest(prNumber, 'squash');
          
          if (mergeSuccess) {
            successCount++;
            mergedBranches.push(branch);
            
            // Test application health after merge
            await this.delay(3000);
            const healthOk = await this.testApplicationHealth();
            
            if (healthOk) {
              console.log(`‚úÖ ${branch} merged successfully and app is healthy`);
              
              // Delete the merged branch
              await this.delay(1000);
              await this.deleteBranch(branch);
            } else {
              console.log(`‚ö†Ô∏è ${branch} merged but health check failed`);
            }
          } else {
            failureCount++;
            failedBranches.push(branch);
          }
        } else {
          failureCount++;
          failedBranches.push(branch);
        }
      } catch (error) {
        console.error(`‚ùå Error processing ${branch}:`, error);
        failureCount++;
        failedBranches.push(branch);
      }
      
      // Pause between branches
      await this.delay(2000);
    }

    // Step 2: Create PR to merge codex into main
    console.log(`\nüéØ Creating final integration PR: codex ‚Üí main`);
    
    try {
      const finalPR = await this.createPullRequest('codex', 'main', 'Final Integration: Merge codex branch into main');
      
      if (finalPR) {
        console.log('‚è≥ Waiting before final merge...');
        await this.delay(5000);
        
        const finalMergeSuccess = await this.mergePullRequest(finalPR, 'merge');
        
        if (finalMergeSuccess) {
          console.log('üéâ Final integration successful!');
          
          // Final health check
          await this.delay(5000);
          const finalHealth = await this.testApplicationHealth();
          
          if (finalHealth) {
            console.log('‚úÖ All integrations complete! Application is healthy.');
          } else {
            console.log('‚ö†Ô∏è Final integration complete but health check failed. Manual review needed.');
          }
          
          // Delete codex branch after successful integration
          await this.delay(2000);
          await this.deleteBranch('codex');
        }
      }
    } catch (error) {
      console.error('‚ùå Error during final integration:', error);
    }

    // Summary Report
    console.log('\n' + '=' .repeat(80));
    console.log('üìä INTEGRATION SUMMARY');
    console.log('=' .repeat(80));
    console.log(`‚úÖ Successfully integrated: ${successCount} branches`);
    console.log(`‚ùå Failed integrations: ${failureCount} branches`);
    
    if (mergedBranches.length > 0) {
      console.log(`\nüéØ Successfully Merged Branches:`);
      mergedBranches.forEach((branch, index) => {
        console.log(`   ${index + 1}. ${branch}`);
      });
    }
    
    if (failedBranches.length > 0) {
      console.log(`\n‚ö†Ô∏è Failed Branches (require manual attention):`);
      failedBranches.forEach((branch, index) => {
        console.log(`   ${index + 1}. ${branch}`);
      });
    }
    
    console.log(`\nüìã Manual Action Required:`);
    console.log(`   ‚Ä¢ PR #19 (feature/stop-right-side-scroll-after-amenities) has merge conflicts`);
    console.log(`   ‚Ä¢ This PR requires manual conflict resolution`);
    
    console.log('\n‚úÖ Systematic integration complete!');
  }
}

// Execute the integration
async function main() {
  const integration = new SystematicBranchIntegration();
  await integration.executeSystematicIntegration();
}

main().catch(console.error);