#!/usr/bin/env tsx

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface MergeItem {
  type: 'pr' | 'branch';
  id: string | number;
  name: string;
  complexity: 'Low' | 'Medium' | 'High';
  description: string;
  targetBranch?: string;
  files?: number;
  additions?: number;
  deletions?: number;
}

class GitHubMergeManager {
  private token: string;
  private owner: string = 'stagesen';
  private repo: string = 'stage-senior-platform';
  private baseURL: string = 'https://api.github.com';

  constructor() {
    this.token = process.env.GITHUB_TOKEN || '';
    if (!this.token) {
      throw new Error('GITHUB_TOKEN environment variable is required');
    }
  }

  private async makeRequest(endpoint: string, options: any = {}): Promise<any> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Stage-Senior-Merge-Manager',
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`GitHub API request failed: ${response.status} ${response.statusText}\n${errorText}`);
    }

    return response.json();
  }

  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async testApplicationHealth(): Promise<boolean> {
    console.log('üîç Testing application health...');
    try {
      // Test if the application is responding
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('http://localhost:5000/api/communities', {
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        console.log('‚úÖ Application is healthy and responding');
        return true;
      } else {
        console.log(`‚ùå Application responded with status: ${response.status}`);
        return false;
      }
    } catch (error) {
      console.log(`‚ùå Application health check failed: ${error}`);
      return false;
    }
  }

  async mergePullRequest(prNumber: number, mergeMethod: 'merge' | 'squash' | 'rebase' = 'squash'): Promise<boolean> {
    console.log(`üîÑ Merging PR #${prNumber} using ${mergeMethod} method...`);
    
    try {
      const mergeResult = await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls/${prNumber}/merge`, {
        method: 'PUT',
        body: JSON.stringify({
          commit_title: `Merge PR #${prNumber}`,
          commit_message: `Automatically merged via merge manager`,
          merge_method: mergeMethod
        })
      });

      console.log(`‚úÖ Successfully merged PR #${prNumber}`);
      console.log(`   SHA: ${mergeResult.sha}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to merge PR #${prNumber}:`, error);
      return false;
    }
  }

  async createPullRequest(headBranch: string, baseBranch: string = 'main', title?: string): Promise<number | null> {
    const prTitle = title || `Merge ${headBranch} into ${baseBranch}`;
    console.log(`üìù Creating pull request: ${headBranch} ‚Üí ${baseBranch}`);
    
    try {
      const pr = await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls`, {
        method: 'POST',
        body: JSON.stringify({
          title: prTitle,
          head: headBranch,
          base: baseBranch,
          body: `Automatically created pull request for merging ${headBranch} into ${baseBranch}\n\n**Generated by merge manager**`
        })
      });

      console.log(`‚úÖ Created PR #${pr.number}: ${prTitle}`);
      return pr.number;
    } catch (error) {
      console.error(`‚ùå Failed to create pull request for ${headBranch}:`, error);
      return null;
    }
  }

  async deleteBranch(branchName: string): Promise<boolean> {
    console.log(`üóëÔ∏è Deleting branch: ${branchName}`);
    
    try {
      await this.makeRequest(`/repos/${this.owner}/${this.repo}/git/refs/heads/${branchName}`, {
        method: 'DELETE'
      });

      console.log(`‚úÖ Successfully deleted branch: ${branchName}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to delete branch ${branchName}:`, error);
      return false;
    }
  }

  async getPullRequestDetails(prNumber: number): Promise<any> {
    return await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls/${prNumber}`);
  }

  async changeBaseOfPullRequest(prNumber: number, newBase: string): Promise<boolean> {
    console.log(`üîÑ Changing base of PR #${prNumber} to ${newBase}...`);
    
    try {
      await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls/${prNumber}`, {
        method: 'PATCH',
        body: JSON.stringify({
          base: newBase
        })
      });

      console.log(`‚úÖ Successfully changed base of PR #${prNumber} to ${newBase}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to change base of PR #${prNumber}:`, error);
      return false;
    }
  }

  async executeSystemMergeStrategy(): Promise<void> {
    console.log('üöÄ Starting Systematic Branch Merge Process');
    console.log('=' .repeat(80));

    // Step 1: Get current state
    const branches = await this.makeRequest(`/repos/${this.owner}/${this.repo}/branches?per_page=100`);
    const prs = await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls?state=open&per_page=100`);

    console.log(`üìä Current state: ${branches.length} branches, ${prs.length} open PRs`);

    // Step 2: Analyze the merge strategy
    const codexPRs = prs.filter((pr: any) => pr.base.ref === 'codex');
    const mainPRs = prs.filter((pr: any) => pr.base.ref === 'main');

    console.log(`\nüîç PR Analysis:`);
    console.log(`   PRs targeting 'codex': ${codexPRs.length}`);
    console.log(`   PRs targeting 'main': ${mainPRs.length}`);

    if (codexPRs.length > 0) {
      console.log(`\n‚ö†Ô∏è  STRATEGIC DECISION NEEDED:`);
      console.log(`   Most PRs target 'codex' branch, suggesting it's an integration branch.`);
      console.log(`   Options:`);
      console.log(`   A) Merge all PRs into 'codex', then merge 'codex' ‚Üí 'main'`);
      console.log(`   B) Change PR targets from 'codex' ‚Üí 'main', then merge directly`);
      console.log(`   C) First merge 'codex' ‚Üí 'main', then handle remaining PRs`);
      
      console.log(`\nüìã Recommended approach: Option A (Integration branch strategy)`);
      console.log(`   This preserves the intended integration workflow.`);
    }

    // Step 3: Execute merge plan
    await this.executeMergePlan(prs, branches);
  }

  async executeMergePlan(prs: any[], branches: any[]): Promise<void> {
    console.log('\nüéØ EXECUTING MERGE PLAN');
    console.log('-' .repeat(50));

    // Sort PRs by complexity (low to high)
    const sortedPRs = prs.sort((a, b) => {
      const aComplexity = this.assessPRComplexity(a);
      const bComplexity = this.assessPRComplexity(b);
      const complexityOrder = { 'Low': 1, 'Medium': 2, 'High': 3 };
      return complexityOrder[aComplexity] - complexityOrder[bComplexity];
    });

    let successCount = 0;
    let failureCount = 0;

    for (const pr of sortedPRs) {
      console.log(`\nüîÑ Processing PR #${pr.number}: ${pr.title}`);
      console.log(`   Complexity: ${this.assessPRComplexity(pr)}`);
      console.log(`   ${pr.head.ref} ‚Üí ${pr.base.ref}`);

      // Check if mergeable
      if (pr.mergeable === false) {
        console.log(`‚ö†Ô∏è  PR #${pr.number} has conflicts - skipping for manual resolution`);
        failureCount++;
        continue;
      }

      // Attempt merge
      const mergeSuccess = await this.mergePullRequest(pr.number, 'squash');
      
      if (mergeSuccess) {
        successCount++;
        
        // Test application after merge
        await this.delay(3000); // Wait for workflow restart
        const healthOk = await this.testApplicationHealth();
        
        if (!healthOk) {
          console.log(`‚ö†Ô∏è  Application health check failed after merging PR #${pr.number}`);
          console.log(`   Manual intervention may be required`);
        }

        // Delete source branch if it's a feature branch
        if (pr.head.ref.startsWith('feature/') || pr.head.ref.includes('codex/')) {
          await this.deleteBranch(pr.head.ref);
        }
      } else {
        failureCount++;
      }

      // Pause between merges
      await this.delay(2000);
    }

    console.log('\nüìä MERGE SUMMARY');
    console.log(`‚úÖ Successful merges: ${successCount}`);
    console.log(`‚ùå Failed merges: ${failureCount}`);
    console.log(`üìù Total PRs processed: ${sortedPRs.length}`);
  }

  private assessPRComplexity(pr: any): 'Low' | 'Medium' | 'High' {
    if (pr.changed_files <= 3 && pr.additions + pr.deletions <= 100) {
      return 'Low';
    }
    if (pr.changed_files <= 10 && pr.additions + pr.deletions <= 500) {
      return 'Medium';
    }
    return 'High';
  }

  async performCodexIntegration(): Promise<void> {
    console.log('üåø CODEX INTEGRATION STRATEGY');
    console.log('-' .repeat(50));

    try {
      // First, merge all open PRs into codex
      const codexPRs = await this.makeRequest(`/repos/${this.owner}/${this.repo}/pulls?base=codex&state=open`);
      
      console.log(`üìä Found ${codexPRs.length} PRs targeting codex branch`);
      
      for (const pr of codexPRs) {
        if (pr.mergeable !== false) {
          console.log(`üîÑ Merging PR #${pr.number} into codex: ${pr.title}`);
          await this.mergePullRequest(pr.number, 'squash');
          await this.delay(2000);
        }
      }

      // Then create and merge codex ‚Üí main PR
      console.log('\nüéØ Creating codex ‚Üí main integration PR...');
      const integrationPR = await this.createPullRequest('codex', 'main', 'Integration: Merge codex branch into main');
      
      if (integrationPR) {
        console.log('‚è≥ Waiting for CI checks...');
        await this.delay(5000);
        
        // Get updated PR details
        const prDetails = await this.getPullRequestDetails(integrationPR);
        
        if (prDetails.mergeable !== false) {
          console.log('üéâ Merging codex into main...');
          await this.mergePullRequest(integrationPR, 'merge'); // Use merge for integration
          
          // Final health check
          await this.delay(5000);
          const finalHealth = await this.testApplicationHealth();
          
          if (finalHealth) {
            console.log('‚úÖ Integration complete! Application is healthy.');
          } else {
            console.log('‚ö†Ô∏è  Integration complete but health check failed. Manual review needed.');
          }
        }
      }

    } catch (error) {
      console.error('‚ùå Error during codex integration:', error);
    }
  }
}

// Command line interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'full';

  const manager = new GitHubMergeManager();

  switch (command) {
    case 'analyze':
      console.log('üìä Analysis mode - use github-integration-analysis.ts');
      break;
    case 'codex':
      await manager.performCodexIntegration();
      break;
    case 'full':
    default:
      await manager.executeSystemMergeStrategy();
      break;
  }
}

main().catch(console.error);